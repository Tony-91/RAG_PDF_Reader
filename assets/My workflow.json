{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -2304,
        -176
      ],
      "webhookId": "rag-pdf-webhook",
      "name": "Webhook",
      "id": "493dde59-d163-43bb-bb16-27d4527ecbc1",
      "notes": "Receives PDF and questions from Streamlit app"
    },
    {
      "parameters": {
        "functionCode": "// Debug: Log the full input structure\nconsole.log('Full input structure:', JSON.stringify($input, null, 2));\n\nconst items = $input.all();\nconsole.log('Number of items:', items.length);\n\nif (items.length === 0) {\n  throw new Error('No input data received');\n}\n\nconst firstItem = items[0];\nconst binaryData = firstItem.binary;\nconst jsonData = firstItem.json;\n\nconsole.log('Binary data keys:', binaryData ? Object.keys(binaryData) : 'No binary data');\nconsole.log('JSON data:', jsonData);\n\n// Get the binary data\nlet fileData = null;\nlet fileName = 'document.pdf';\nlet question = 'What is this document about?';\n\n// Check if we have binary data (from file upload)\nif (binaryData && Object.keys(binaryData).length > 0) {\n  console.log('Processing binary data upload');\n  const binaryKey = Object.keys(binaryData)[0];\n  fileData = binaryData[binaryKey];\n  fileName = binaryData[binaryKey].fileName || fileName;\n  console.log(`Found file: ${fileName}, size: ${fileData.data ? fileData.data.length : 'unknown'}`);\n} else if (jsonData) {\n  console.log('Processing JSON data');\n  if (jsonData.fileData) {\n    fileData = jsonData.fileData;\n    fileName = jsonData.fileName || fileName;\n  }\n  question = jsonData.question || question;\n}\n\nconsole.log('Final file data:', fileData ? 'Present' : 'Missing');\nconsole.log('Question:', question);\n\n// Return the data for the next nodes\nconst result = {\n  json: {\n    question,\n    debug: {\n      receivedBinary: !!binaryData,\n      receivedJson: !!jsonData,\n      fileName\n    }\n  },\n  binary: {}\n};\n\n// Only add binary data if we have it\nif (fileData) {\n  console.log('Adding binary data to output');\n  result.binary = {\n    fileData: {\n      data: fileData.data || fileData,\n      mimeType: 'application/pdf',\n      fileName: fileName\n    }\n  };\n} else {\n  console.log('No file data to add to output');\n}\n\nconsole.log('Final output structure:', JSON.stringify({\n  ...result,\n  binary: result.binary ? 'BINARY_DATA_PRESENT' : 'NO_BINARY_DATA'\n}, null, 2));\n\nreturn result;"
      },
      "name": "Parse Webhook Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -2096,
        -176
      ],
      "id": "d6cbf5a7-68cc-452c-9409-26d66c8684f8"
    },
    {
      "parameters": {
        "fileName": "={{ $json.fileName || 'document.pdf' }}",
        "dataPropertyName": "fileData",
        "options": {}
      },
      "name": "Save PDF",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -1904,
        -176
      ],
      "id": "56b81169-8de8-4efc-9922-b5a08b6bf9a9"
    },
    {
      "parameters": {
        "functionCode": "// Get the file extension\nconst fileName = $input.item.json.fileName || 'document.pdf';\nconst fileExt = fileName.split('.').pop().toLowerCase();\n\n// Return the file info\nreturn {\n  json: {\n    fileName,\n    fileExtension: fileExt,\n    isPdf: fileExt === 'pdf',\n    isJson: fileExt === 'json'\n  },\n  binary: $input.item.binary\n};"
      },
      "name": "Check File Type",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -1248,
        240
      ],
      "id": "check-file-type-node"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.isPdf}}",
              "operation": "equal",
              "value2": true
            }
          ]
        },
        "options": {}
      },
      "name": "Is PDF?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1040,
        240
      ],
      "id": "is-pdf-node"
    },
    {
      "parameters": {
        "dataType": "binary",
        "textSplittingMode": "custom",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1.1,
      "position": [
        -832,
        160
      ],
      "name": "PDF Loader",
      "id": "pdf-loader-node"
    },
    {
      "parameters": {
        "operation": "readFile",
        "filePath": "={{$json.fileName}}",
        "options": {}
      },
      "name": "Read JSON File",
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1.1,
      "position": [
        -832,
        320
      ],
      "id": "read-json-node"
    },
    {
      "parameters": {
        "functionCode": "// Parse the JSON content and format it for the next node\nconst jsonContent = JSON.parse($input.first().json.fileContent);\nreturn {\n  json: {\n    ...$input.first().json,\n    parsedJson: jsonContent\n  }\n};"
      },
      "name": "Parse JSON",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -624,
        320
      ],
      "id": "parse-json-node"
    },
    {
      "parameters": {
        "functionCode": "// Merge the data from both branches\nlet result = [];\n\n// Check if we have PDF data\nif ($input.all().some(item => item.json?.isPdf)) {\n  result = result.concat($input.all().filter(item => item.json?.isPdf));\n}\n\n// Check if we have JSON data\nif ($input.all().some(item => item.json?.parsedJson)) {\n  result = result.concat($input.all().filter(item => item.json?.parsedJson));\n}\n\nreturn result;"
      },
      "name": "Merge Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -416,
        240
      ],
      "id": "merge-data-node"
    },
    {
      "parameters": {
        "chunkSize": 400,
        "chunkOverlap": 100,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        -1456,
        320
      ],
      "name": "Recursive Character Text Splitter",
      "id": "974cba9b-e08c-4a79-a5e3-9bb45f799a72"
    },
    {
      "parameters": {
        "model": "mxbai-embed-large:latest"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        -2080,
        432
      ],
      "name": "Embeddings Ollama",
      "id": "2655dd1e-7c2b-4b2a-af4e-0d26280c3b6a",
      "credentials": {
        "ollamaApi": {
          "id": "xHuYe0MDGOs9IpBW",
          "name": "Local Ollama service"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "qdrantCollection": {
          "__rl": true,
          "value": "rag_chatbot",
          "mode": "id"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreQdrant",
      "typeVersion": 1.3,
      "position": [
        -1712,
        -176
      ],
      "name": "Qdrant Vector Store",
      "id": "267b876c-1652-4826-8640-e46c57972bf6",
      "credentials": {
        "qdrantApi": {
          "id": "sFfERYppMeBnFNeA",
          "name": "Local QdrantApi database"
        }
      }
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolDescription": "db_retriever",
        "qdrantCollection": {
          "__rl": true,
          "value": "rag_chatbot",
          "mode": "id"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreQdrant",
      "typeVersion": 1.3,
      "position": [
        -80,
        560
      ],
      "name": "Qdrant Vector Store (Retriever)",
      "id": "87eb712f-63e5-4ec5-80af-644e519f1e83",
      "credentials": {
        "qdrantApi": {
          "id": "sFfERYppMeBnFNeA",
          "name": "Local QdrantApi database"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -480,
        160
      ],
      "name": "Simple Memory",
      "id": "fd0ca7f0-0dfc-43cb-a5d7-f15d493c05b5"
    },
    {
      "parameters": {
        "model": "llama3.2:latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        -656,
        144
      ],
      "name": "Ollama Chat Model",
      "id": "ae18b9a7-8743-4aef-828a-28b5f150dd19",
      "credentials": {
        "ollamaApi": {
          "id": "xHuYe0MDGOs9IpBW",
          "name": "Local Ollama service"
        }
      }
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "You are an expert on the United States Declaration of Independence. Your purpose is to provide accurate, insightful, and engaging information about this foundational American document. When responding:\n\n1. Maintain a knowledgeable yet approachable tone\n2. Provide historical context and significance\n3. Explain 18th-century language in modern terms\n4. Highlight key principles like natural rights and government by consent\n5. Be objective about historical context and controversies\n6. Use quotes from the document when relevant\n7. Explain the document's lasting impact on democracy\n\nIf asked about topics beyond the Declaration's scope, politely redirect to relevant aspects of the document. Always cite historical sources when making specific claims. Use your vector database (tool: db_retriever) to answer the questions. If you can't answer a question just reply with \"I don't know\" "
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -512,
        -256
      ],
      "name": "AI Agent",
      "id": "287529c0-0d04-4fb2-93bc-1b62d6ff614d"
    },
    {
      "parameters": {
        "functionCode": "// Format the final response\nconst response = $input.first().json;\nreturn {\n  json: {\n    answer: response.text || response,\n    success: true\n  }\n};"
      },
      "name": "Format Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -64,
        96
      ],
      "id": "1b46582a-1d05-4a89-9316-e74e905a0890"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -832,
        -256
      ],
      "id": "763c9b3e-f72b-4fb7-8e9c-dd0607f4f898",
      "name": "When chat message received",
      "webhookId": "b810c6b4-07e5-4fd5-8db4-c62552fc3931"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Webhook Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Webhook Data": {
      "main": [
        [
          {
            "node": "Save PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save PDF": {
      "main": [
        [
          {
            "node": "Qdrant Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama": {
      "ai_embedding": [
        [
          {
            "node": "Qdrant Vector Store",
            "type": "ai_embedding",
            "index": 0
          },
          {
            "node": "Qdrant Vector Store (Retriever)",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Qdrant Vector Store (Retriever)": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Qdrant Vector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "cb35c238-deb6-4a19-9539-f04aeb77adec",
  "meta": {
    "instanceId": "558d88703fb65b2d0e44613bc35916258b0f0bf983c5d4730c00c424b77ca36a"
  },
  "id": "Q5IZk3958THBar97",
  "tags": []
}